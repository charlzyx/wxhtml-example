{"version":3,"sources":["html5parser.cjs.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tslib = require('tslib');\n\n/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-18 15:17:51\n * @version 1.0.0\n * @desc types.ts\n */\nexports.SyntaxKind = void 0;\n(function (SyntaxKind) {\n    SyntaxKind[\"Text\"] = \"Text\";\n    SyntaxKind[\"Tag\"] = \"Tag\";\n})(exports.SyntaxKind || (exports.SyntaxKind = {}));\n\n/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-19 00:54:29\n * @version 1.0.0\n * @desc tokenize.ts\n */\nvar state;\nvar buffer$1;\nvar bufSize;\nvar sectionStart;\nvar index$1;\nvar tokens$1;\nvar char;\nvar inScript;\nvar inStyle;\nvar offset;\nfunction makeCodePoints(input) {\n    return {\n        lower: input\n            .toLowerCase()\n            .split('')\n            .map(function (c) { return c.charCodeAt(0); }),\n        upper: input\n            .toUpperCase()\n            .split('')\n            .map(function (c) { return c.charCodeAt(0); }),\n        length: input.length,\n    };\n}\nvar doctype = makeCodePoints('!doctype');\nvar style = makeCodePoints('style');\nvar script = makeCodePoints('script');\nfunction isWhiteSpace() {\n    return (char === 32 /* _S */ ||\n        char === 10 /* _N */ ||\n        char === 9 /* _T */ ||\n        char === 9 /* _T */ ||\n        char === 13 /* _R */ ||\n        char === 12 /* _F */);\n}\nfunction init$1(input) {\n    state = 0 /* Literal */;\n    buffer$1 = input;\n    bufSize = input.length;\n    sectionStart = 0;\n    index$1 = 0;\n    tokens$1 = [];\n    inScript = false;\n    inStyle = false;\n    offset = 0;\n}\nfunction tokenize(input) {\n    init$1(input);\n    while (index$1 < bufSize) {\n        char = buffer$1.charCodeAt(index$1);\n        switch (state) {\n            case 0 /* Literal */:\n                parseLiteral();\n                break;\n            case 1 /* BeforeOpenTag */:\n                parseBeforeOpenTag();\n                break;\n            case 2 /* OpeningTag */:\n                parseOpeningTag();\n                break;\n            case 3 /* AfterOpenTag */:\n                parseAfterOpenTag();\n                break;\n            case 4 /* InValueNq */:\n                parseInValueNq();\n                break;\n            case 5 /* InValueSq */:\n                parseInValueSq();\n                break;\n            case 6 /* InValueDq */:\n                parseInValueDq();\n                break;\n            case 7 /* ClosingOpenTag */:\n                parseClosingOpenTag();\n                break;\n            case 8 /* OpeningSpecial */:\n                parseOpeningSpecial();\n                break;\n            case 9 /* OpeningDoctype */:\n                parseOpeningDoctype();\n                break;\n            case 10 /* OpeningNormalComment */:\n                parseOpeningNormalComment();\n                break;\n            case 11 /* InNormalComment */:\n                parseNormalComment();\n                break;\n            case 12 /* InShortComment */:\n                parseShortComment();\n                break;\n            case 13 /* ClosingNormalComment */:\n                parseClosingNormalComment();\n                break;\n            case 14 /* ClosingTag */:\n                parseClosingTag();\n                break;\n            default:\n                unexpected$1();\n                break;\n        }\n        index$1++;\n    }\n    switch (state) {\n        case 0 /* Literal */:\n        case 1 /* BeforeOpenTag */:\n        case 4 /* InValueNq */:\n        case 5 /* InValueSq */:\n        case 6 /* InValueDq */:\n        case 7 /* ClosingOpenTag */:\n        case 11 /* InNormalComment */:\n        case 12 /* InShortComment */:\n        case 13 /* ClosingNormalComment */:\n            emitToken(0 /* Literal */);\n            break;\n        case 2 /* OpeningTag */:\n            emitToken(1 /* OpenTag */);\n            break;\n        case 3 /* AfterOpenTag */:\n            break;\n        case 8 /* OpeningSpecial */:\n            emitToken(1 /* OpenTag */, 12 /* InShortComment */);\n            break;\n        case 9 /* OpeningDoctype */:\n            if (index$1 - sectionStart === doctype.length) {\n                emitToken(1 /* OpenTag */);\n            }\n            else {\n                emitToken(1 /* OpenTag */, void 0, sectionStart + 1);\n                emitToken(0 /* Literal */);\n            }\n            break;\n        case 10 /* OpeningNormalComment */:\n            if (index$1 - sectionStart === 2) {\n                emitToken(1 /* OpenTag */);\n            }\n            else {\n                emitToken(1 /* OpenTag */, void 0, sectionStart + 1);\n                emitToken(0 /* Literal */);\n            }\n            break;\n        case 14 /* ClosingTag */:\n            emitToken(3 /* CloseTag */);\n            break;\n    }\n    var _tokens = tokens$1;\n    init$1('');\n    return _tokens;\n}\nfunction emitToken(kind, newState, end) {\n    if (newState === void 0) { newState = state; }\n    if (end === void 0) { end = index$1; }\n    var value = buffer$1.substring(sectionStart, end);\n    if (kind === 1 /* OpenTag */ || kind === 3 /* CloseTag */) {\n        value = value.toLowerCase();\n    }\n    if (kind === 1 /* OpenTag */) {\n        if (value === 'script') {\n            inScript = true;\n        }\n        else if (value === 'style') {\n            inStyle = true;\n        }\n    }\n    if (kind === 3 /* CloseTag */) {\n        inScript = inStyle = false;\n    }\n    if (!((kind === 0 /* Literal */ || kind === 4 /* Whitespace */) && end === sectionStart)) {\n        // empty literal should be ignored\n        tokens$1.push({ type: kind, start: sectionStart, end: end, value: value });\n    }\n    if (kind === 2 /* OpenTagEnd */ || kind === 3 /* CloseTag */) {\n        sectionStart = end + 1;\n        state = 0 /* Literal */;\n    }\n    else {\n        sectionStart = end;\n        state = newState;\n    }\n}\nfunction parseLiteral() {\n    if (char === 60 /* Lt */) {\n        // <\n        emitToken(0 /* Literal */, 1 /* BeforeOpenTag */);\n    }\n}\nfunction parseBeforeOpenTag() {\n    if (inScript || inStyle) {\n        if (char === 47 /* Sl */) {\n            state = 14 /* ClosingTag */;\n            sectionStart = index$1 + 1;\n        }\n        else {\n            state = 0 /* Literal */;\n        }\n        return;\n    }\n    if ((char >= 97 /* La */ && char <= 122 /* Lz */) || (char >= 65 /* Ua */ && char <= 90 /* Uz */)) {\n        // <d\n        state = 2 /* OpeningTag */;\n        sectionStart = index$1;\n    }\n    else if (char === 47 /* Sl */) {\n        // </\n        state = 14 /* ClosingTag */;\n        sectionStart = index$1 + 1;\n    }\n    else if (char === 60 /* Lt */) {\n        // <<\n        emitToken(0 /* Literal */);\n    }\n    else if (char === 33 /* Ep */) {\n        // <!\n        state = 8 /* OpeningSpecial */;\n        sectionStart = index$1;\n    }\n    else if (char === 63 /* Qm */) {\n        // <?\n        // treat as short comment\n        sectionStart = index$1;\n        emitToken(1 /* OpenTag */, 12 /* InShortComment */);\n    }\n    else {\n        // <>\n        // any other chars covert to normal state\n        state = 0 /* Literal */;\n    }\n}\nfunction parseOpeningTag() {\n    if (isWhiteSpace()) {\n        // <div ...\n        emitToken(1 /* OpenTag */, 3 /* AfterOpenTag */);\n    }\n    else if (char === 62 /* Gt */) {\n        // <div>\n        emitToken(1 /* OpenTag */);\n        emitToken(2 /* OpenTagEnd */);\n    }\n    else if (char === 47 /* Sl */) {\n        // <div/\n        emitToken(1 /* OpenTag */, 7 /* ClosingOpenTag */);\n    }\n}\nfunction parseAfterOpenTag() {\n    if (char === 62 /* Gt */) {\n        // <div >\n        emitToken(4 /* Whitespace */);\n        emitToken(2 /* OpenTagEnd */);\n    }\n    else if (char === 47 /* Sl */) {\n        // <div /\n        emitToken(4 /* Whitespace */, 7 /* ClosingOpenTag */);\n    }\n    else if (char === 61 /* Eq */) {\n        // <div ...=...\n        emitToken(4 /* Whitespace */);\n        emitToken(5 /* AttrValueEq */, void 0, index$1 + 1);\n    }\n    else if (char === 39 /* Sq */) {\n        // <div ...'...\n        emitToken(4 /* Whitespace */, 5 /* InValueSq */);\n    }\n    else if (char === 34 /* Dq */) {\n        // <div ...\"...\n        emitToken(4 /* Whitespace */, 6 /* InValueDq */);\n    }\n    else if (!isWhiteSpace()) {\n        // <div ...name...\n        emitToken(4 /* Whitespace */, 4 /* InValueNq */);\n    }\n}\nfunction parseInValueNq() {\n    if (char === 62 /* Gt */) {\n        // <div xxx>\n        emitToken(6 /* AttrValueNq */);\n        emitToken(2 /* OpenTagEnd */);\n    }\n    else if (char === 47 /* Sl */) {\n        // <div xxx/\n        emitToken(6 /* AttrValueNq */, 7 /* ClosingOpenTag */);\n    }\n    else if (char === 61 /* Eq */) {\n        // <div xxx=\n        emitToken(6 /* AttrValueNq */);\n        emitToken(5 /* AttrValueEq */, 3 /* AfterOpenTag */, index$1 + 1);\n    }\n    else if (isWhiteSpace()) {\n        // <div xxx ...\n        emitToken(6 /* AttrValueNq */, 3 /* AfterOpenTag */);\n    }\n}\nfunction parseInValueSq() {\n    if (char === 39 /* Sq */) {\n        // <div 'xxx'\n        emitToken(7 /* AttrValueSq */, 3 /* AfterOpenTag */, index$1 + 1);\n    }\n}\nfunction parseInValueDq() {\n    if (char === 34 /* Dq */) {\n        // <div \"xxx\", problem same to Sq\n        emitToken(8 /* AttrValueDq */, 3 /* AfterOpenTag */, index$1 + 1);\n    }\n}\nfunction parseClosingOpenTag() {\n    if (char === 62 /* Gt */) {\n        // <div />\n        emitToken(2 /* OpenTagEnd */);\n    }\n    else {\n        // <div /...>\n        emitToken(6 /* AttrValueNq */, 3 /* AfterOpenTag */);\n        parseAfterOpenTag();\n    }\n}\nfunction parseOpeningSpecial() {\n    switch (char) {\n        case 45 /* Cl */: // <!-\n            state = 10 /* OpeningNormalComment */;\n            break;\n        case 100 /* Ld */: // <!d\n        case 68 /* Ud */: // <!D\n            state = 9 /* OpeningDoctype */;\n            break;\n        default:\n            emitToken(1 /* OpenTag */, 12 /* InShortComment */);\n            break;\n    }\n}\nfunction parseOpeningDoctype() {\n    offset = index$1 - sectionStart;\n    if (offset === doctype.length) {\n        // <!d, <!d , start: 0, index: 2\n        if (isWhiteSpace()) {\n            emitToken(1 /* OpenTag */, 3 /* AfterOpenTag */);\n        }\n        else {\n            unexpected$1();\n        }\n    }\n    else if (char === 62 /* Gt */) {\n        // <!DOCT>\n        emitToken(1 /* OpenTag */, void 0, sectionStart + 1);\n        emitToken(0 /* Literal */);\n        emitToken(2 /* OpenTagEnd */);\n    }\n    else if (doctype.lower[offset] !== char && doctype.upper[offset] !== char) {\n        // <!DOCX...\n        emitToken(1 /* OpenTag */, 12 /* InShortComment */, sectionStart + 1);\n    }\n}\nfunction parseOpeningNormalComment() {\n    if (char === 45 /* Cl */) {\n        // <!--\n        emitToken(1 /* OpenTag */, 11 /* InNormalComment */, index$1 + 1);\n    }\n    else {\n        emitToken(1 /* OpenTag */, 12 /* InShortComment */, sectionStart + 1);\n    }\n}\nfunction parseNormalComment() {\n    if (char === 45 /* Cl */) {\n        // <!-- ... -\n        emitToken(0 /* Literal */, 13 /* ClosingNormalComment */);\n    }\n}\nfunction parseShortComment() {\n    if (char === 62 /* Gt */) {\n        // <! ... >\n        emitToken(0 /* Literal */);\n        emitToken(2 /* OpenTagEnd */);\n    }\n}\nfunction parseClosingNormalComment() {\n    offset = index$1 - sectionStart;\n    if (offset === 2) {\n        if (char === 62 /* Gt */) {\n            // <!-- xxx -->\n            emitToken(2 /* OpenTagEnd */);\n        }\n        else if (char === 45 /* Cl */) {\n            // <!-- xxx ---\n            emitToken(0 /* Literal */, void 0, sectionStart + 1);\n        }\n        else {\n            // <!-- xxx --x\n            state = 11 /* InNormalComment */;\n        }\n    }\n    else if (char !== 45 /* Cl */) {\n        // <!-- xxx - ...\n        state = 11 /* InNormalComment */;\n    }\n}\nfunction parseClosingTag() {\n    offset = index$1 - sectionStart;\n    if (inStyle) {\n        if (char === 60 /* Lt */) {\n            sectionStart -= 2;\n            emitToken(0 /* Literal */, 1 /* BeforeOpenTag */);\n        }\n        else if (offset < style.length) {\n            if (style.lower[offset] !== char && style.upper[offset] !== char) {\n                sectionStart -= 2;\n                state = 0 /* Literal */;\n            }\n        }\n        else if (char === 62 /* Gt */) {\n            emitToken(3 /* CloseTag */);\n        }\n        else if (!isWhiteSpace()) {\n            sectionStart -= 2;\n            state = 0 /* Literal */;\n        }\n    }\n    else if (inScript) {\n        if (char === 60 /* Lt */) {\n            sectionStart -= 2;\n            emitToken(0 /* Literal */, 1 /* BeforeOpenTag */);\n        }\n        else if (offset < script.length) {\n            if (script.lower[offset] !== char && script.upper[offset] !== char) {\n                sectionStart -= 2;\n                state = 0 /* Literal */;\n            }\n        }\n        else if (char === 62 /* Gt */) {\n            emitToken(3 /* CloseTag */);\n        }\n        else if (!isWhiteSpace()) {\n            sectionStart -= 2;\n            state = 0 /* Literal */;\n        }\n    }\n    else if (char === 62 /* Gt */) {\n        // </ xxx >\n        emitToken(3 /* CloseTag */);\n    }\n}\nfunction unexpected$1() {\n    throw new SyntaxError(\"Unexpected token \\\"\" + buffer$1.charAt(index$1) + \"\\\" at \" + index$1 + \" when parse \" + state);\n}\n\n/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-19 15:56:14\n * @version 1.0.0\n * @desc config.ts\n */\nfunction createMap(keys, value) {\n    return keys.split(',').reduce(function (pre, now) {\n        pre[now] = value;\n        return pre;\n    }, Object.create(null));\n}\nvar selfCloseTags = createMap('area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr,!doctype,,!,!--', true);\nvar noNestedTags = createMap('li,option,select,textarea', true);\n\n/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-20 21:41:39\n * @version 1.0.0\n * @desc utils.ts\n */\nfunction getLineRanges(input) {\n    return input.split('\\n').reduce(function (arr, line) {\n        arr.push(line.length + 1 + arr[arr.length - 1]);\n        return arr;\n    }, [0]);\n}\nfunction getPosition(ranges, offset) {\n    var line = NaN;\n    var column = NaN;\n    for (var i = 1; i < ranges.length; i++) {\n        if (ranges[i] > offset) {\n            line = i;\n            column = offset - ranges[i - 1] + 1;\n            break;\n        }\n    }\n    return [line, column];\n}\n\n/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-19 00:54:46\n * @version 1.0.0\n * @desc walk.ts\n */\nfunction visit(node, parent, index, options) {\n    options.enter && options.enter(node, parent, index);\n    if (node.type === exports.SyntaxKind.Tag && Array.isArray(node.body)) {\n        for (var i = 0; i < node.body.length; i++) {\n            visit(node.body[i], node, i, options);\n        }\n    }\n    options.leave && options.leave(node, parent, index);\n}\nfunction walk(ast, options) {\n    for (var i = 0; i < ast.length; i++) {\n        visit(ast[i], void 0, i, options);\n    }\n}\n\n/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-19 00:54:46\n * @version 1.0.0\n * @desc parse.ts\n */\nvar index;\nvar count;\nvar tokens;\nvar tagChain;\nvar nodes;\nvar token;\nvar node;\nvar buffer;\nvar lines;\nvar parseOptions;\nfunction init(input, options) {\n    if (input === void 0) {\n        count = 0;\n        tokens.length = 0;\n        buffer = '';\n    }\n    else {\n        tokens = tokenize(input);\n        count = tokens.length;\n        buffer = input;\n    }\n    index = 0;\n    tagChain = void 0;\n    nodes = [];\n    token = void 0;\n    node = void 0;\n    lines = void 0;\n    parseOptions = options;\n}\nfunction pushNode(_node) {\n    if (!tagChain) {\n        nodes.push(_node);\n    }\n    else if (_node.type === exports.SyntaxKind.Tag &&\n        _node.name === tagChain.tag.name &&\n        noNestedTags[_node.name]) {\n        tagChain = tagChain.parent;\n        pushNode(_node);\n    }\n    else if (tagChain.tag.body) {\n        tagChain.tag.end = _node.end;\n        tagChain.tag.body.push(_node);\n    }\n}\nfunction pushTagChain(tag) {\n    tagChain = { parent: tagChain, tag: tag };\n    node = void 0;\n}\nfunction createLiteral(start, end, value) {\n    if (start === void 0) { start = token.start; }\n    if (end === void 0) { end = token.end; }\n    if (value === void 0) { value = token.value; }\n    return { start: start, end: end, value: value, type: exports.SyntaxKind.Text };\n}\nfunction createTag() {\n    return {\n        start: token.start - 1,\n        end: token.end,\n        type: exports.SyntaxKind.Tag,\n        open: createLiteral(token.start - 1),\n        name: token.value,\n        rawName: buffer.substring(token.start, token.end),\n        attributes: [],\n        attributeMap: void 0,\n        body: null,\n        close: null,\n    };\n}\nfunction createAttribute() {\n    return {\n        start: token.start,\n        end: token.end,\n        name: createLiteral(),\n        value: void 0,\n    };\n}\nfunction createAttributeValue() {\n    return {\n        start: token.start,\n        end: token.end,\n        value: token.type === 6 /* AttrValueNq */\n            ? token.value\n            : token.value.substr(1, token.value.length - 2),\n        quote: token.type === 6 /* AttrValueNq */\n            ? void 0\n            : token.type === 7 /* AttrValueSq */\n                ? \"'\"\n                : '\"',\n    };\n}\nfunction appendLiteral(_node) {\n    if (_node === void 0) { _node = node; }\n    _node.value += token.value;\n    _node.end = token.end;\n}\nfunction unexpected() {\n    if (lines === void 0) {\n        lines = getLineRanges(buffer);\n    }\n    var _a = tslib.__read(getPosition(lines, token.start), 2), line = _a[0], column = _a[1];\n    throw new Error(\"Unexpected token \\\"\" + token.value + \"(\" + token.type + \")\\\" at [\" + line + \",\" + column + \"]\" +\n        (tagChain ? \" when parsing tag: \" + JSON.stringify(tagChain.tag.name) + \".\" : ''));\n}\nfunction buildAttributeMap(tag) {\n    var e_1, _a;\n    tag.attributeMap = {};\n    try {\n        for (var _b = tslib.__values(tag.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var attr = _c.value;\n            tag.attributeMap[attr.name.value] = attr;\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n}\nfunction parseOpenTag() {\n    var state = 0 /* BeforeAttr */;\n    var attr = void 0;\n    var tag = createTag();\n    pushNode(tag);\n    if (tag.name === '' || tag.name === '!' || tag.name === '!--') {\n        tag.open.value = '<' + tag.open.value;\n        if (index === count) {\n            return;\n        }\n        else {\n            token = tokens[++index];\n            if (token.type !== 2 /* OpenTagEnd */) {\n                node = createLiteral();\n                tag.body = [node];\n                while (++index < count) {\n                    token = tokens[index];\n                    if (token.type === 2 /* OpenTagEnd */) {\n                        node = void 0;\n                        break;\n                    }\n                    appendLiteral();\n                }\n            }\n            tag.close = createLiteral(token.start, token.end + 1, token.value + \">\");\n            tag.end = tag.close.end;\n        }\n        return;\n    }\n    while (++index < count) {\n        token = tokens[index];\n        if (token.type === 2 /* OpenTagEnd */) {\n            tag.end = tag.open.end = token.end + 1;\n            tag.open.value = buffer.substring(tag.open.start, tag.open.end);\n            if (token.value === '' && !selfCloseTags[tag.name]) {\n                tag.body = [];\n                pushTagChain(tag);\n            }\n            else {\n                tag.body = void 0;\n            }\n            break;\n        }\n        else if (state === 0 /* BeforeAttr */) {\n            if (token.type !== 4 /* Whitespace */) {\n                attr = createAttribute();\n                state = 1 /* InName */;\n                tag.attributes.push(attr);\n            }\n        }\n        else if (state === 1 /* InName */) {\n            if (token.type === 4 /* Whitespace */) {\n                state = 2 /* AfterName */;\n            }\n            else if (token.type === 5 /* AttrValueEq */) {\n                state = 3 /* AfterEqual */;\n            }\n            else {\n                appendLiteral(attr.name);\n            }\n        }\n        else if (state === 2 /* AfterName */) {\n            if (token.type !== 4 /* Whitespace */) {\n                if (token.type === 5 /* AttrValueEq */) {\n                    state = 3 /* AfterEqual */;\n                }\n                else {\n                    attr = createAttribute();\n                    state = 1 /* InName */;\n                    tag.attributes.push(attr);\n                }\n            }\n        }\n        else if (state === 3 /* AfterEqual */) {\n            if (token.type !== 4 /* Whitespace */) {\n                attr.value = createAttributeValue();\n                if (token.type === 6 /* AttrValueNq */) {\n                    state = 4 /* InValue */;\n                }\n                else {\n                    attr.end = attr.value.end;\n                    state = 0 /* BeforeAttr */;\n                }\n            }\n        }\n        else {\n            if (token.type === 4 /* Whitespace */) {\n                attr.end = attr.value.end;\n                state = 0 /* BeforeAttr */;\n            }\n            else {\n                appendLiteral(attr.value);\n            }\n        }\n    }\n}\nfunction parseCloseTag() {\n    var _context = tagChain;\n    while (true) {\n        if (!_context || token.value.trim() === _context.tag.name) {\n            break;\n        }\n        _context = _context.parent;\n    }\n    if (!_context) {\n        return;\n    }\n    _context.tag.close = createLiteral(token.start - 2, token.end + 1, buffer.substring(token.start - 2, token.end + 1));\n    _context.tag.end = _context.tag.close.end;\n    _context = _context.parent;\n    tagChain = _context;\n}\nfunction parse(input, options) {\n    init(input, tslib.__assign({ setAttributeMap: false }, options));\n    while (index < count) {\n        token = tokens[index];\n        switch (token.type) {\n            case 0 /* Literal */:\n                if (!node) {\n                    node = createLiteral();\n                    pushNode(node);\n                }\n                else {\n                    appendLiteral(node);\n                }\n                break;\n            case 1 /* OpenTag */:\n                node = void 0;\n                parseOpenTag();\n                break;\n            case 3 /* CloseTag */:\n                node = void 0;\n                parseCloseTag();\n                break;\n            default:\n                unexpected();\n                break;\n        }\n        index++;\n    }\n    var _nodes = nodes;\n    if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.setAttributeMap) {\n        walk(_nodes, {\n            enter: function (node) {\n                if (node.type === exports.SyntaxKind.Tag) {\n                    buildAttributeMap(node);\n                }\n            },\n        });\n    }\n    init();\n    return _nodes;\n}\n\n/*\n * @since 2020-09-09 22:53:14\n * @author acrazing <joking.young@gmail.com>\n */\nvar safeHtmlDefaultOptions = {\n    allowedTags: [\n        'a',\n        'abbr',\n        'address',\n        'area',\n        'article',\n        'aside',\n        'b',\n        'bdi',\n        'bdo',\n        'big',\n        'blockquote',\n        'br',\n        'button',\n        'caption',\n        'cite',\n        'code',\n        'col',\n        'colgroup',\n        'data',\n        'dd',\n        'del',\n        'dfn',\n        'div',\n        'dl',\n        'dt',\n        'em',\n        'figcaption',\n        'figure',\n        'footer',\n        'h1',\n        'h2',\n        'h3',\n        'h4',\n        'h5',\n        'h6',\n        'header',\n        'hgroup',\n        'hr',\n        'i',\n        'img',\n        'ins',\n        'kbd',\n        'label',\n        'li',\n        'main',\n        'map',\n        'ol',\n        'p',\n        'picture',\n        'pre',\n        'q',\n        'rp',\n        'rt',\n        'ruby',\n        's',\n        'samp',\n        'section',\n        'small',\n        'span',\n        'strong',\n        'sub',\n        'summary',\n        'sup',\n        'table',\n        'tbody',\n        'td',\n        'tfoot',\n        'th',\n        'thead',\n        'time',\n        'tr',\n        'u',\n        'ul',\n        'var',\n        'wbr',\n    ],\n    allowedAttrs: ['style'],\n    tagAllowedAttrs: {\n        a: ['href', 'target'],\n        img: ['src'],\n        td: ['rowspan', 'colspan'],\n        th: ['rowspan', 'colspan'],\n        time: ['datetime'],\n        colgroup: ['span'],\n        col: ['span'],\n    },\n    allowedUrl: /^(?:mailto|tel|https?|ftp|[^:]*[^a-z0-9.+-][^:]*):|^[^:]*$/i,\n};\nfunction safeHtml(input, options) {\n    if (options === void 0) { options = {}; }\n    var config = tslib.__assign(tslib.__assign(tslib.__assign({}, safeHtmlDefaultOptions), options), { tagAllowedAttrs: tslib.__assign(tslib.__assign({}, safeHtmlDefaultOptions.tagAllowedAttrs), options.tagAllowedAttrs) });\n    var ast = parse(input);\n    return stringify(ast, config, input);\n}\nfunction stringify(ast, config, input) {\n    return ast\n        .map(function (node) {\n        if (node.type === exports.SyntaxKind.Text) {\n            return node.value;\n        }\n        if (config.allowedTags.indexOf(node.name) === -1) {\n            return '';\n        }\n        if (selfCloseTags[node.name]) {\n            if (node.body !== void 0) {\n                throw new Error(\"self closed tag \\\"\" + node.name + \"\\\" should not have body\");\n            }\n        }\n        else {\n            if (!node.body || !node.close) {\n                throw new Error(\"tag \\\"\" + node.name + \"\\\" should have body and close\");\n            }\n        }\n        var attrs = node.attributes\n            .filter(function (a) {\n            var _a;\n            if (config.allowedAttrs.indexOf(a.name.value) > -1 ||\n                ((_a = config.tagAllowedAttrs[node.name]) === null || _a === void 0 ? void 0 : _a.indexOf(a.name.value)) > -1) {\n                if (!a.value) {\n                    return true;\n                }\n                if (a.name.value !== 'src' && a.name.value !== 'href') {\n                    return true;\n                }\n                if (config.allowedUrl.test(a.value.value)) {\n                    return true;\n                }\n                return false;\n            }\n            return false;\n        })\n            .map(function (a) { return input.substring(a.start, a.end); })\n            .join(' ');\n        var head = '<' + node.rawName + (attrs ? ' ' + attrs : '') + '>';\n        if (!node.body) {\n            return head;\n        }\n        return head + stringify(node.body, config, input) + (\"</\" + node.rawName + \">\");\n    })\n        .join('');\n}\n\nexports.parse = parse;\nexports.safeHtml = safeHtml;\nexports.safeHtmlDefaultOptions = safeHtmlDefaultOptions;\nexports.tokenize = tokenize;\nexports.walk = walk;\n//# sourceMappingURL=html5parser.cjs.js.map\n"]}